* Basic
  ** Working Directory
     *** getwd()
     *** setwd("folder名")

  ** Directory
     *** dir(), list.files(): List all the files in your working directory
     *** dir.create("folder名")
     *** dir.create(file.path("testdir2", "testdir3"), recursive = TRUE)

  ** File
     *** file.create("檔名")
     *** file.exists("檔名")
     *** file.info("檔名")
     *** file.rename("檔名1", "檔名2"): 改名從檔名1到檔名2
     *** file.copy("檔名1", "檔名2"): Make a copy of "檔名1" called "檔名2"
     *** file.path("檔名"): Provide the relative path to the file "檔名"
         file.path("folder1", "folder2"):

  ** Delete
     *** unlink("testdir2", recursive=TRUE)

  ** 把多個expression用{和}包覆起來，變成一個大的expression
  ** 註解：#
  ** 一個函數的細節說明: help(函數名) 或 ?函數名
  ** example(函數名)
  ** args(函數名): to see the arguments to list.files
  ** objects()或ls():列出所有目前存在的object的名字
     ls(): to see a list of the variables in your workspace
  ** rm(): 刪除已經存在的物件
     rm(list=ls()): clear your workspace

  ** NA: Not available; 判斷一個向量裡面有沒有NA: is.na(x)
     *** Removing NA values
         ****
         x <- c(1, 2, NA, 4, NA, 5)
         bad <- is.na(x)
         x[!bad]
         [1] 1 2 4 5

         **** complete.cases():
              What if there are multiple things and you want to take the subset
              with no missing values

              x <- c(1, 2, NA, 4, NA, 5)
              y <- c("a", "b", NA, "d", NA, "f")
              good <- complete.cases(x, y)
              good
              [1]  TRUE  TRUE FALSE  TRUE FALSE  TRUE
              x[good]
              [1] 1 2 4 5
              y[good]
              [1] "a" "b" "d" "f"

              remove missing values from data frames

              airquality[1:6, ]
                  Ozone Solar.R Wind Temp Month Day
              1    41     190  7.4   67     5   1
              2    36     118  8.0   72     5   2
              3    12     149 12.6   74     5   3
              4    18     313 11.5   62     5   4
              5    NA      NA 14.3   56     5   5
              6    28      NA 14.9   66     5   6
              good <- complete.cases(airquality)
              airquality[good, ][1:6, ]

                  Ozone Solar.R Wind Temp Month Day
              1    41     190  7.4   67     5   1
              2    36     118  8.0   72     5   2
              3    12     149 12.6   74     5   3
              4    18     313 11.5   62     5   4
              7    23     299  8.6   65     5   7
              8    19      99 13.8   59     5   8

         **** xxxFunction(vector, na.rm = TRUE)

     *** NaN: Not A Number; is.nan()
     *** NA is not NaN
         NaN is NA
  ** Inf: 無限大

  ** unclass(xx): to see what xx looks like internally
  ** R內建有許多知名的資料集。這些內建的資料集，目前都在datasets這個套件之中
     library(help=datasets)  #檢視所有的資料集
     data(iris, package = "datasets") #這些列出的資料中，我們可以運用data這個指令來載入，從套件datasets中載入資料集iris。
  ** library(套件名) e.g. library(stringi)
  ** source("myfunction.R")

* Reading Tabular Data
  ** 測試檔案的編碼
     *** 先檢查檔案有沒有BOM。BOM 是一種利用檔案最前面的2 個或 3 個位元組來標示檔案編碼的方式。
         在windows底下建立的中文檔案， 有很高的機會會帶BOM。

         readBin("xxx.csv", what = "raw", n = 3)

         R 中的`readBin` 是一個很可以直接讀取檔案中的位元組的指令，所以可以正確的處理BOM。
         第一個參數是檔案的路徑。第二個名稱為what的參數，是告訴R 要如何處理讀入的資料。
         `what = "raw"`代表讀入的資料用位元處理，而不是文字。
         第三個名稱為n 的參數，代表要輸入的長度。這裡選`n = 3` 是因為通常BOM 最多就是3個位元組。
         ”https://zh.wikipedia.org/wiki/位元組順序記號“:查詢常用的BOM

         如果沒有BOM ，一種方法是使用`file`搭配`readLines` 兩個函數來測試。
         如果讀出來的中文可以正常顯示，通常我們就猜中編碼了。
         如果讀出亂碼，或是讀取發生錯誤，那可能就猜錯了，就換個編碼猜猜看。

         readLines(file("xxx.csv", encoding = "BIG5"), n = 1)

         這裡的file指令會打開一個檔案，第一個參數是檔案的路徑，第二個名稱為encoding的參數代表檔案的編碼。
         如果是BIG5編碼，就輸入名稱："BIG5"。UTF-8的話，就輸入"UTF-8"。
         file函數會建立一個代表檔案的物件，在R之中叫做“connection”。
         R會不定時的關閉不使用的connection，並且在console 顯示警告訊息。

         readLines()函數會一行一行的讀取檔案的內容。
         第一個參數就是用file函數開啟的檔案。
         第二個名稱為n 的參數，則代表讀取的行數。
         這裡`n=1`代表讀取一行，所以只會回傳一個 素的character 向量。

         有時候，由於不明原因，R 還是會發生無法讀取特定編碼的狀況。
         這時候，我們可以先把資料以位元的方式讀取到R中，再做轉碼。
         在程式的世界中，資料在電腦中最終都是儲存為0 和1 的位元。
         在處理資料時，程式需要先對資料有一些認識才能做處理，例如把資料當成字串、整數或浮點數。
         文字的資料才會被編碼影響，所以如果我們只是用位元來處理檔案的內容，就可以避開編碼的問題。

         R 是型態為raw 的向量來處理位元的物件。
         只要能知道檔案的大小， readBin就可以把所有的檔案資料以raw 的形式輸入到R 中。
         我們可以使用`file.info`來查詢檔案的大小。

         透過stringi套件的`stri_encode`，我們可以把一個位元組的向量（在R中，這類向量的型態是raw）
         從一個編碼轉換為另一個編碼。
         e.g. lvr_land.txt <- stri_encode(lvr_land.bin, "BIG-5", "UTF-8")

  ** Reading tabular data
     *** read.table(): one of the most commonly used functions for reading data, default sep = " "

         注意read.table的參數fileEncoding的用法，這個參數雖然可以解碼，但只能用在file參數為字串的case。

         第二個重要的參數，是`header`。`header = TRUE`代表檔案的第一行是欄位名稱，而不是資料。
         `header=FALSE`代表檔案的第一行就是資料。

         第三個重要的參數是`sep` ，這代表各行欄位間的分隔符號。

         e.g.
         lvr_land <- read.table(file(lvr_land.path, encoding = "BIG5"), header = TRUE, sep = ",")
         如果我們要直接從lvr_land.txt的內容取出表格，一種方法是直接把lvr_land.txt寫成一個檔案，再用read.table讀取。
         另外一種方法，是把lvr_land.txt視為一個類似檔案的物件，也就是connection。

         在windows上，有一個很不方便的地方，是接下來的作法和Windows的語系有關。
         如果Windows的語系有支援多位元組字串（例如中文、日文等語系），那語法需要調整。

         用l10n_info()來查詢作業系統對於各種Encoding的支援狀況。
         l10n_info()會回報系統對是否有支援UTF-8（UTF-8 欄位），或是多位元組字串（MBCS欄位）。

         根據經驗，如果l10n_info()的輸出中，

         MBCS為TRUE且UTF-8為FALSE，則要使用：textConnection(lvr_land.txt)來從`lvr_land.txt`建立一個connection。
         除此之外，則使用textConnection(lvr_land.txt, encoding = "UTF-8")即可。

         在 MBCS為TRUE 且 UTF-8為FALSE 時執行：
         read.table(textConnection(lvr_land.txt), header = TRUE, sep = ",")

         否則，執行：
         read.table(textConnection(lvr_land.txt, encoding = "UTF-8"), header = TRUE, sep = ",")

         initial <- read.table("xxx.txt", nrows = 100)
         classes <- sapply(initial, class)
         tabAll <- read.table("xxx.txt", colClasses = classes)

     *** read.csv("xxx.csv"): sep = ","

     *** readLines(): deading lines of text file

     *** source(): reading in R code files (inverse of dump)
     *** dget(): reading in R code files (inverse of dput)
     *** load(): reading in saved workspaces
     *** unserialize(): reading single R objects in binary form

  ** Writing Dara
     *** write.table
     *** writeLines
     *** dump
     *** dput
     *** save
     *** serialize

* Connections: Interfaces to the Outside World
  ** con <- file("xxx.txt", "r")
     data <- read.csv(con)
     close(con)

     is the same as

     data <- read.csv("xxx.txt")

  ** con <- gzfile("xxx.gz")
     x <- readLines(con, 10)

  ** con <- url("http://xxx.xxx.xxx", "r")
     x <- readLines(con)

* Object
  ** R的object結構是針對資料分析所設計的。所以最簡單的object，就是一連串的數字;
     R和其他的程式語言不同，因為一般的程式語言最簡單的object會是一個數字;
     R這樣設計的理由是因為在資料分析的應用中，我們一定是處理一些資料，而不會只有一筆資料
     在R中，我們操作的所有變數，都是一種R物件(Object)，在所有物件中，最基礎的「原子」物件，就是各種向量
     向量物件有兩個很重要的屬性：
     - mode: 代表這個向量的值型態(logical、integer、numeric、complex、character和raw)
     - length: 代表這個向量的值的個數
               更改一個向量的長度。舉例來說，x是一個長度是5、型態是numeric的向量。我們可以利用：length(x)<-10把x的長度改成10，多出來的為NULL
   ** R has 5 basic "atomic" classes of objects
      - character
      - numeric (real numbers)
      - integer
      - complex
      - logical (True/False)

* Vector
  ** The simplest and most common data structure in R is the vector
     Vectors come in two different flavors: atomic vectors and lists.
     An atomic vector contains exactly one data type
     A list may contain multiple data types.
  ** + - * / ^
     min(x), min(x), range(x), sum(x), length(x), sqrt(x)
     var(x) #樣本變異數
     sd(x) #樣本標準差
     sort(x)
  ** seq(1:10) == 1:10
     seq(from, to, by, length.out, along.with,...)
     length.out: 長度
     by: 間隔
  ** 重複一個數字: rep(2,times=10)
     將整個序列重複times次: rep(x, times = 2)
     把向量的每一個值個別重複each遍之後: rep(x, each = 2)
  ** c(1,2,3,4) + c(0,10)
     [1]  1 12  3 14

     c(1,2,3,4)+c(1,10,100)
     [1]   2  12 103   5

  ** x[c(1,3)]
     x[x > 5]
     x[-2]: 挑x_除了_第二個之外的全部的值

  ** names(x) <- c("a", "b", "c", "d")
     x[c("b", "d")]: 選取名稱為c("b","d")的值

  ** identical(vect, vect2)

  ** List: List的本質，其實就是一個「R物件的向量」，每一個值都是R物件，都有自己的mode、length等屬性

     list(3, a = 2)

     [[1]]
     [1] 3
     R顯示了[[1]]，然後才顯示一個值為3的numeric向量。開頭的[[1]]不只說明了這個物件是一個list，也說明接下來顯示的是第一個值的內容。

     $a
     [1] 2
     R顯示了$a，然後才顯示了一個值為2的numeric向量。開頭的$a因為位置在第二，所以代表這是這個list物件的第二個值。同時，這個值的名字是"a"。

     x[1]
     [[1]]
     [1] 3

     x[[1]]
     [1] 3

     mode(x)
     [1] "list"

     mode(x[1]): 使用x[1]時，R取出向量的第一個元素，並且維持list的結構，所以x[1]的結果還仍是list
     [1] "list"

     mode(x[[1]]): 使用g[[1]]時，R會打破list的結構，再取出向量的第一個元素，所以g[[1]]的型態會是存放在list裡面的R物件的型態
     [1] "numeric"

     一般來說，對R物件使用[]之後，會取得會和該物件相同的物件。舉例來說，a[1]的型態會和a一樣。而[[]]就沒有類似的特性
     輸出的型態是否仍是list，就是[[]]和[]主要的不同。
     也由於list是一種向量，所以諸如length之類我們學過得函數，都是可以在list上使用的。

     可以為list命名: 用x[[2]]來取得第二個值之外，也可以用g[["a"]]來取得第二個值。因為x這個向量是被命名的，而第二個名字就是"a"
     x[["a"]]
     [1] 2

     length(x[[1]])
     [1] 1

     c(2,4,6)
     [1] 2 4 6

     1:10
     [1]  1  2  3  4  5  6  7  8  9 10

     1:100
     [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
     [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
     [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
     [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72
     [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
     [91]  91  92  93  94  95  96  97  98  99 100

     x <- list(3, a = c(2,4,6))
     x
     [[1]]
     [1] 3

     $a
     [1] 2 4 6

     x["a"]
     $a
     [1] 2 4 6

     x[["a"]]
     [1] 2 4 6

     mode(x["a"])
     [1] "list"

     mode(x[["a"]])
     [1] "numeric"

     ** Subsetting
        x <- list(foo = 1:4, bar = 0.6, baz = "hello")
        x[c(1, 3)]
        $foo
        [1] 1 2 3 4

        $baz
        [1] "hello"

        The [[ can take an integer sequence
        x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
        x[[c(1, 3)]]
        [1] 14
        x[[1]][[3]]
        [1] 14

        x[[c(2, 1)]]
        [1] 3.14

        sub = subset(airquality, is.na(Ozone)) # airquality is data.frame
        sub = subset(airquality, !is.na(Ozone), select = Ozone)
        sub = subset(airquality, Ozone > 31 & Temp > 90, select = Solar.R)
        sub = subset(airquality, Month == 6, select = Temp)
        sub = subset(airquality, Month == 5 & !is.na(Ozone), select = Ozone)


     ** To make things a little more interesting, lets create a vector containing
        1000 draws from a standard normal distribution with y <- rnorm(1000).

     ** Finally, let's select 100 elements at random from these 2000 values
        (combining y and z) such that we don't know how many NAs we'll wind up with
        or what positions they'll occupy in our final vector -- my_data <-
        sample(c(y, z), 100).

     ** 所有的R物件，都有「屬性」(attributes)。我們可以用attributes這個函數來印出一個R物件的屬性
        attributes(x)
        $names
        [1] ""  "a" ""  ""

        names(x)
        [1] ""  "a" ""  ""

        attr(x, "names")
        [1] ""  "a" ""  ""

* Factor
  ** blood_type_factor <- factor(blood_type)
     levels(blood_type_factor)
  ** x <- factor(c("yes","yes","no","yes","no"))
     x
     [1] yes yes no yes no
     levels: no yes

     table(x)
     x
     no yes
      2   3

     unclass(x)
     [1] 2 2 1 2 1
     attr(, "levels")
     [1] "no" "yes"

* Matrix
  ** matrix(1:18,6,3)
  ** array(1:18,c(3,3,2)): 來建立一個高維矩陣
  ** cbind(matrix(1:4, 2, 2), matrix(1:4, 2, 2))
  ** rbind(matrix(1:4, 2, 2), matrix(1:4, 2, 2))
  ** dimnames(m) <- list(c("a","b"), c("c","d"))
                          ^^^^^^^^row ^^^^^^^^column name
  ** %*%: 矩陣乘法, matrix(1:6,2,3) %*% matrix(3:8,3,2)
  ** t(matrix(1:4,2,2)): Transpose
  ** diag(1, 3): 快速建構對角化的矩陣, diag快速建構對角化的矩陣
  ** 如果已知A%*%x = b，給定A和b我們可以用solve解出x。
     舉例來說，若A是matrix(1:4,2,2)、b是c(3,8)，solve(A,b)就會給出x。
     x <- solve(A, b)
  ** 直接使用solve(A)，則R會算出A的反矩陣
  ** eigen(A)則可以解出A的特徵值(eigen values)和特徵向量(eigen vectors)
  ** By default, when a single element of a matrix is retrieved,
     it is returned as a vector of length 1 rather than a 1x1 matrix.
     This behavior can be turned off by setting drop = FALSE
     x <- matrix(1:6, 2, 3)
     x[1, 2]
     [1] 3

     x[1, 2, drop = FALSE]
         [,1]
     [1,]  3

     x[1, ]
     [1] 1 3 5

     x[1, , drop = FALSE]
          [,1] [,2] [,3]
     [1,]    1    3    5


* data.frame
  ** 傳統的matrix和array有同質性的限制（所有的元素都要同樣的型態）
     data.frame是一種list。因為表格的各欄是型態不一的向量，所以我們需要用list來裝不同型態的向量。
     因為表格的資料是結構化的，所以data.frame的值不能存放太奇怪的物件。
     具體來說，data.frame的各個元素必須是以下幾種類型之一：

     - 數值(numeric)
     - 字串(character)
     - 布林(logical)
     - 類別(factor)
     - 數值矩陣(numeric matrix)
     - list
     - data.frame

     因為data.frame代表的是二維表格，所以每一個值的長度都要一致（矩陣或data.frame的話，則是列(row)的個數）。
     這種特性讓我們在整理資料上是非常的方便。

  ** a <- data.frame(class = "NTU", id = 1:10,scores = matrix(c(80:99),nrow=10,ncol=2))
     nrow(a): 列出a所包含的列數
     ncol(a): 列出a所包含的欄數
     dim(a): 一次列出兩者
     colnames(a): 取出a的欄位名稱


* Dates & Times

** Dates are represented by the 'Date' class
   Times are represented by the 'POSIXct' and 'POSIXlt' classes.

   *** dates are stored as the number of days since 1970-01-01

       d1 <- Sys.Date()
       unclass(d1)
       [1] 16983
       d2 <- as.Date("1969-01-01")
       [a] -365

   *** times are stored as:
       either the number of "seconds" since 1970-01-01 (for 'POSIXct')
       or a list of seconds, minutes, hours, etc. (for 'POSIXlt').

       t1 <- Sys.time() # By default, return an object of class POSIXct
       class(t1)
       [1] "POSIXct" "POSIXt"
       unclass(t1)
       [1] 1467335707

       t2 <- as.POSIXlt(Sys.time()) # coerce the result to POSIXlt with as.POSIXlt(Sys.time())
       unclass(t2)
       $sec
       [1] 20.90358

       $min
       [1] 16

       $hour
       [1] 9

       $mday
       [1] 1

       $mon
       [1] 6

       $year
       [1] 116

       $wday
       [1] 5

       $yday
       [1] 182

       $isdst
       [1] 0

       $zone
       [1] "CST"

       $gmtoff
       [1] 28800

       attr(,"tzone")
       [1] ""    "CST" "CDT"

    *** weekdays(), months(), and quarters(): extract useful information from any of these objects

    *** strptime(): converts character vectors to POSIXlt.
        t3 <- "October 17, 1986 08:24"
        t4 <- strptime(t3, "%B %d, %Y %H:%M")
        class(t4)
        [1] "POSIXlt" "POSIXt"

    *** Operations on Dates & Times
        Sys.time() > t1
        [1] TRUE

        Sys.time() - t1
        Time difference of 1.360523 hours

        difftime(Sys.time(), t1, units = 'days')
        Time difference of 0.05699589 days


* For loop
  x <- c("a", "b", "c", "d")
  for(i in 1:4) {
      print(x[i])
  }

  for (i in seq_along(x)) {
      print(x[i])
  }

  for(letter in x) {
      print(letter)
  }

  for(i in 1:4) print(x[i])

  x <- matrix(1:6, 2, 3)
  for(i in seq_len(nrow(x))) {
      for(j in seq_len(ncol(x))) {
          print(x[i, j])
      }
  }

  seq_len():可產生特定長度之序列，比較特別的地方是它可以處理長度為零的序列：
  seq_along(): 可以產生一個跟輸入向量相同長度的序列，而序列的內容就是從 1 到輸入向量的長度值
  seq_along 可以產生一個跟輸入向量相同長度的序列，而序列的內容就是從 1 到輸入向量的長度值

* Scoping Rules
  ** Symbol Binding
     When R tries to bind a value to a symbol, it searches through a series of
     environments to find the appropriate value. When you are working on the
     command line and need to retrieve the value of an R object, the order is roughly
     1. Search the global environment for a symbol name matching the one requested
        - global environment, it's just the workspace, and it consists of all the
          things that you've defined or load into R
     2. Search the namespaces of each of the packages on the search list
        - The search list can be found by using the search function

  ** Scoping Rules
     *** Lexical Scoping: the values of free variables are searched for in the
         environment in which the function was defined
         - What is an environment?
           . An environment is a collection of (symbol, value) pairs
           . Every environment has a parent environment;it is possible for an
             environment to have multiple "children"
           . the only environment without a parent is the empty environment
           . A function + an environment = a closure or function closure
     *** Lexical vs. Dynamic Scoping
         y <- 10

         f <- function(x) {
             y <- 2
             y^2 + g(x)
         }

         g <- function(x) {
             x * y
         }

         What is the value of f(3)?

         - With lexical scoping the value of y in the function g
           is looked up in the environment in which the function was defined,
           in this case the global environment, so the value of y is 10
         - With dynamic scoping, the value of y is looked up in the environment
           from which the function was called (sometimes referred to as the
           calling environment).
           . In R the calling environment is known as the parent frame
           . So the value of y would be 2


* 字串
  ** 把argument以字串的形式接成一個字串: paste(...) paste也是一個向量化的函數
     my_char <- c("My", "name", "is")
     paste(my_char)
     [1] "My"   "name" "is"

     paste(my_char, collapse = " ")
     [1] "My name is"
     The `collapse` argument to the paste() function tells R that when we join
     together the elements of the my_char character vector, we'd like to separate
     them with single spaces.

     paste("a", "b")
     [1] "a b"

     paste(c("X","Y"), 1:10)
     [1] "X 1"  "Y 2"  "X 3"  "Y 4"  "X 5"  "Y 6"  "X 7"  "Y 8"  "X 9"  "Y 10"

     paste("Hello", "world!", sep = " ")
     [1] "Hello world!"
     `sep` argument tells R that we want to separate the joined elements with a
     single space.

     paste(1:3, c("X", "Y", "Z"), sep = "-")
     [1] "1-X" "2-Y" "3-Z"

  ** paste0預設在串接字串的時候，中間是不會有空格的
